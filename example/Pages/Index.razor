@page "/"
@using Microsoft.AspNetCore.SignalR.Client;
@using System.Threading;
@using Microsoft.JSInterop;
@inject IJSRuntime JSRuntime

<div id="canv" @onmousemove="MoveMouse" @onmousedown="DownMouse" @onmouseup="UpMouse"
     @ontouchmove="MoveTouch" @ontouchstart="DownTouch" @ontouchend="UpTouch"
     style="border:2px solid black;display:inline-block;max-height:80vh;max-width:100vw;overflow:hidden;">
    <svg style="width:800px; height:800px;" id="svg">
    </svg>
</div>
<div>
    <span>@status/@count lines</span>
    <button @onclick="@(e => Use(Tool.BlackPen))">Use Black pen</button>
    <button @onclick="@(e => Use(Tool.RedPen))">Use Red pen</button>
    <button @onclick="@(e => Use(Tool.Eraser))">Use Eraser</button>
    <button @onclick="Clear">Clear Image</button>
</div>

@code {
    protected enum Tool
    {
        BlackPen,
        RedPen,
        Eraser
    }

    protected List<Line> Lines = new List<Line>();
    protected bool flag = false;
    protected bool dot_flag = false;

    protected double prevX = 0;
    protected double currX = 0;
    protected double prevY = 0;
    protected double currY = 0;

    protected int count = 0;

    protected int status = 0;

    protected string color = "black";
    protected float lineWidth = 2;

    private IJSObjectReference SVG;
    protected System.Runtime.Serialization.IObjectReference SVGElement;

    private async Task MoveMouse(MouseEventArgs e)
    {
        await Move(e.ClientX, e.ClientY);
    }
    private async Task MoveTouch(TouchEventArgs e)
    {
        await Move(e.Touches[0].ClientX, e.Touches[0].ClientY);
    }
    private async Task Move(double clientX, double clientY)
    {
        if (flag)
        {
            prevX = currX;
            prevY = currY;
            currX = clientX;
            currY = clientY;

            var addedLine = new Line(prevX, prevY, currX, currY, color, lineWidth);
            Lines.Add(addedLine);

            if (color != "white")
            {
                await Draw(addedLine);
            }
            else
            {
                Lines.ForEach(async line =>
                {
                    if (doIntersect(prevX, prevY, currX, currY, line.prevX, line.prevY, line.currX, line.currY))
                    {
                        await SVG.InvokeVoidAsync("removeLine", (line.prevX + line.prevY + line.currX + line.currY));
                    }
                });
                Lines.RemoveAll(line => doIntersect(prevX, prevY, currX, currY, line.prevX, line.prevY, line.currX, line.currY));
            }
            await hubConnection.SendAsync("Draw", prevX, prevY, currX, currY, color, lineWidth);

            status++;
            count++;
            this.StateHasChanged();
        }
    }

    private async Task DownMouse(MouseEventArgs e)
    {
        await Down(e.ClientX, e.ClientY);
    }
    private async Task DownTouch(TouchEventArgs e)
    {
        await Down(e.Touches[0].ClientX, e.Touches[0].ClientY);
    }
    private async Task Down(double clientX, double clientY)
    {
        prevX = currX;
        prevY = currY;
        currX = clientX;
        currY = clientY;

        flag = true;
    }

    private void UpMouse(MouseEventArgs e)
    {
        flag = false;
    }
    private void UpTouch(TouchEventArgs e)
    {
        flag = false;
    }

    private void Use(Tool tool)
    {
        switch (tool)
        {
            case Tool.BlackPen:
                color = "black";
                lineWidth = 2;
                break;
            case Tool.RedPen:
                color = "red";
                lineWidth = 2;
                break;
            default:
                color = "white";
                lineWidth = 10;
                break;
        }
    }

    private HubConnection hubConnection;
    private List<string> messages = new List<string>();
    private string userInput;
    private string messageInput;

    protected override async Task OnInitializedAsync()
    {
        SVG = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/SVGInterface.js").AsTask();

        hubConnection = new HubConnectionBuilder()
            .WithUrl("https://kristoffer-strube.dk/API/drawHub")
            .WithAutomaticReconnect()
            .Build();

        hubConnection.Closed += (err) => { async Task Run() { Console.WriteLine(err); }; return Run(); };

        hubConnection.On<double, double, double, double, string, float>("ReceiveDraw", async (SprevX, SprevY, ScurrX, ScurrY, Scolor, SlineWidth) =>
        {
            var addedLine = new Line(SprevX, SprevY, ScurrX, ScurrY, Scolor, SlineWidth);
            Lines.Add(addedLine);
            await Draw(addedLine);

            status++;
            count++;
            this.StateHasChanged();
        });

        hubConnection.On("ReceiveClear", async () =>
        {
            Lines.Clear();
            await SVG.InvokeVoidAsync("clear");
            count = 0;
            status = 0;
            StateHasChanged();
        });

        await hubConnection.StartAsync();

        count = await hubConnection.InvokeAsync<int>("CountLines");

        var cancellationTokenSource = new CancellationTokenSource();
        var stream = hubConnection.StreamAsync<Line>(
            "StartLines", cancellationTokenSource.Token);

        await foreach (Line line in stream)
        {
            await Draw(line);
            status++;
            StateHasChanged();
        }
    }

    public async Task Draw(Line line)
    {
        await SVG.InvokeVoidAsync("addLine", (line.prevX + line.prevY + line.currX + line.currY), line.prevX, line.prevY, line.currX, line.currY, $"stroke:{line.color};stroke-width:{line.lineWidth};");
        Lines.Add(line);
        await Task.CompletedTask;
    }

    protected async Task Clear()
    {
        await hubConnection.SendAsync("Clear");
    }

    public bool IsConnected =>
hubConnection.State == HubConnectionState.Connected;

    public class Line
    {
        public Line() { }
        public Line(double prevX, double prevY, double currX, double currY, string color, float lineWidth)
        {
            this.prevX = prevX;
            this.prevY = prevY;
            this.currX = currX;
            this.currY = currY;
            this.color = color;
            this.lineWidth = lineWidth;
        }
        public double prevX { get; set; }
        public double currX { get; set; }
        public double prevY { get; set; }
        public double currY { get; set; }
        public string color { get; set; }
        public float lineWidth { get; set; }
    }

    // Given three colinear points p, q, r, the function checks if
    // point q lies on line segment 'pr'
    static Boolean onSegment(double px, double py, double qx, double qy, double rx, double ry)
    {
        if (qx <= Math.Max(px, rx) && qx >= Math.Min(px, rx) &&
            qy <= Math.Max(py, ry) && qy >= Math.Min(py, ry))
            return true;

        return false;
    }

    // To find orientation of ordered triplet (p, q, r).
    // The function returns following values
    // 0 --> p, q and r are colinear
    // 1 --> Clockwise
    // 2 --> Counterclockwise
    static int orientation(double px, double py, double qx, double qy, double rx, double ry)
    {
        // See https://www.geeksforgeeks.org/orientation-3-ordered-points/
        // for details of below formula.
        double val = (qy - py) * (rx - qx) -
                (qx - px) * (ry - qy);

        if (val == 0) return 0; // colinear

        return (val > 0) ? 1 : 2; // clock or counterclock wise
    }

    // The main function that returns true if line segment 'p1q1'
    // and 'p2q2' intersect.
    static Boolean doIntersect(double p1x, double p1y, double q1x, double q1y, double p2x, double p2y, double q2x, double q2y)
    {
        // Find the four orientations needed for general and
        // special cases
        int o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y);
        int o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y);
        int o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1x);
        int o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y);

        // General case
        if (o1 != o2 && o3 != o4)
            return true;

        // Special Cases
        // p1x, p1y, q1x, q1y and q2x, q2y are colinear and q2x, q2y lies on segment p1x, p1yq1x, q1y
        if (o2 == 0 && onSegment(p1x, p1y, q2x, q2y, q1x, q1y)) return true;

        // p2x, p2y, q2x, q2y and p1x, p1y are colinear and p1x, p1y lies on segment p2x, p2yq2x, q2y
        if (o3 == 0 && onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) return true;

        // p2x, p2y, q2x, q2y and q1x, q1y are colinear and q1x, q1y lies on segment p2x, p2yq2x, q2y
        if (o4 == 0 && onSegment(p2x, p2y, q1x, q1y, q2x, q2y)) return true;

        return false; // Doesn't fall in any of the above cases
    }

    static Boolean interSectionIsInLineInterval(double p1x, double p1y, double q1x, double q1y, double p2x, double p2y, double q2x, double q2y)
    {
        if (doIntersect(double p1x, double p1y, double q1x, double q1y, double p2x, double p2y, double q2x, double q2y))
        {

        }
    }
}